{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# View\n",
    "\n",
    "This notebook provides the possibility to use the methodes implemented by entering a function and a degree of approximation. Regarding  the quadrature the option\n",
    "\n",
    "* Newton-Cotes, \n",
    "* Trapezoidal, \n",
    "* Monte-Carlo (nested and not nested) and \n",
    "* Quasi-Monte Carlo \n",
    "\n",
    "exist. An other way is calling the View function."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [],
   "source": [
    "# The packages needed here are Tkinter, because the View is implemented using it \n",
    "# and of course the packages of the projekt \n",
    "import tkinter as tk\n",
    "\n",
    "import os\n",
    "os.chdir(\"..\")\n",
    "import Methodes_Studienproject.Studienprojekt_Smolyak_qmc_one_point as Studieproject_one"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 76,
   "metadata": {},
   "outputs": [],
   "source": [
    "from tkinter import messagebox as mbox\n",
    "# View/ Main \n",
    "\n",
    "# In this script we make an interface with tkinter\n",
    "#   The interface has: - An entry line for the function\n",
    "#                      - An entry line for the variables\n",
    "#                      - number of evaluations\n",
    "#                      - Perhaps an entry line to verify dimension\n",
    "#                      - button to start calculation\n",
    "#                      - A separate popup for result showing of\n",
    "#                      - Drop down menu for choosing of quadrature\n",
    "#                      - Several popup for warnings\n",
    "# import tkinter as tk\n",
    "\n",
    "# own files imported\n",
    "# import My_Controller as cont\n",
    "# import controller_smolyak as cont\n",
    "\n",
    "# create main viewer\n",
    "root = tk.Tk()\n",
    "root.title(\"Application for calculation of integral with Smolak algorithm\")\n",
    "root.geometry(\"800x300\")\n",
    "\n",
    "# Label for description of functionality of viewer\n",
    "description = tk.Label(root, text=\"To  use the application you need first need to enter a function in the \"\n",
    "                                  \"entry.\\n\"\n",
    "                                  \"After this the tuple of variables and in the end the quadrature you want to be \"\n",
    "                                  \"used.\\n\"\n",
    "                                  \"The calculation starts after clicking start.\", anchor=\"w\", justify=\"left\")\n",
    "description.grid(row=0, column=0, sticky=\"w\", columnspan=3)\n",
    "\n",
    "#\n",
    "# Column for entry of function\n",
    "func_label = tk.Label(root, text=\"Please enter function: \", justify=\"center\", anchor=\"w\", pady=10, padx=10)\n",
    "func_label.grid(row=1, column=0, sticky=\"w\")\n",
    "\n",
    "func_entry = tk.Entry(root, width=50, borderwidth=5)\n",
    "func_entry.grid(row=1, column=1, sticky=\"e\", padx=20, pady=20, columnspan=2)\n",
    "func_entry.insert(0, \"2 x y\")\n",
    "\n",
    "# Column for entry of variables\n",
    "var_label = tk.Label(root, text=\"Please enter variables: \", justify=\"center\", anchor=\"w\", pady=10, padx=10)\n",
    "var_label.grid(row=2, column=0, sticky=\"w\")\n",
    "\n",
    "var_entry = tk.Entry(root, width=50, borderwidth=5)\n",
    "var_entry.grid(row=2, column=1, sticky=\"e\", padx=20, pady=20, columnspan=2)\n",
    "var_entry.insert(0, \"(x , y)\")\n",
    "\n",
    "# Drop down menu for quadrature\n",
    "\n",
    "# list of quadratures available\n",
    "option_list = [\"Newton-Cotes\",\n",
    "               \"Trapezoidal\",\n",
    "               \"Monte Carlo (nested)\",\n",
    "               \"Monte Carlo (non-nested)\",\n",
    "               \"Quasi-Monte Carlo\"]\n",
    "option = tk.StringVar()\n",
    "option.set(option_list[0])\n",
    "which_quad = tk.OptionMenu(root, option, *option_list)\n",
    "which_quad.grid(row=3, column=2)\n",
    "\n",
    "\n",
    "degree_label = tk.Label(root, text=\"Please choose degree of approximation: \", justify=\"center\", anchor=\"w\",\n",
    "                        pady=10, padx=10)\n",
    "degree_label.grid(row=3, column=0, sticky=\"w\")\n",
    "\n",
    "degree_of_approx = tk.Entry(root, width=10, borderwidth=5)\n",
    "degree_of_approx.grid(row=3, column=1)\n",
    "degree_of_approx.insert(0, 2)\n",
    "\n",
    "# !! Here we also could  think about a button making it possible to define the epsilon-error!!\n",
    "\n",
    "\n",
    "# Start button\n",
    "def start():\n",
    "\n",
    "    # read out entries\n",
    "    function_string = func_entry.get()\n",
    "    variables_string = var_entry.get()\n",
    "    quadrature = option.get()\n",
    "    degree = int(degree_of_approx.get())\n",
    "    \n",
    "    # We want to open an error box, if the degree of approximation is not big enough. Hence, we need to  \n",
    "    # know the dimension of the function. Here we get this by counting the commas.  \n",
    "    if degree < (variables_string.count(\",\")+1):\n",
    "        mbox.showerror(\"Input error\", \"The degree of the approximation needs to be at least as high as the \"\n",
    "                                      \"dimension of m the function. \\n\\nIn this case this would be q = \" \n",
    "                                      + str(variables_string.count(\",\") + 1) + \".\")\n",
    "\n",
    "    \n",
    "    else:\n",
    "       \n",
    "        # ask controller for benchmarks of approximation\n",
    "        result_approx, error, cost = Studieproject.controller_smolyak(function_string, \n",
    "                                                                      variables_string, quadrature, degree)\n",
    "    \n",
    "        # Create new window where results are shown\n",
    "        result_window = tk.Toplevel(root)\n",
    "        result_window.title(\"Result\")\n",
    "        result_window.geometry(\"800x200\")\n",
    "\n",
    "        # Label for result of approx.\n",
    "        result_label = tk.Label(result_window, text=\"The result of the approximation is: \" + str(result_approx),\n",
    "                                justify=\"left\", anchor=\"e\", pady=10, padx=10)\n",
    "        result_label.grid(row=0, column=0, columnspan=2)\n",
    "\n",
    "        # Label for error\n",
    "        error_label = tk.Label(result_window, text=\"Estimated error: \" + str(error), justify=\"center\", anchor=\"w\",\n",
    "                               pady=10, padx=10)\n",
    "        error_label.grid(row=1, column=0)\n",
    "\n",
    "        # Label for cost estimation\n",
    "        cost_label = tk.Label(result_window, text=\"Estimated number of evaluations: \" + str(cost), justify=\"center\",\n",
    "                              anchor=\"w\", pady=10, padx=10)\n",
    "        cost_label.grid(row=1, column=2)\n",
    "\n",
    "        # Quit button of result window\n",
    "        quit_button_result = tk.Button(result_window, text=\"Quit\", command=root.destroy, width=10, borderwidth=5,\n",
    "                                       padx=5, pady=5)\n",
    "        quit_button_result.grid(row=2, column=2)\n",
    "\n",
    "\n",
    "#  Start button\n",
    "start_button = tk.Button(root, text=\"Start\", command=start, width=10, borderwidth=5, padx=5, pady=5)\n",
    "\n",
    "start_button.grid(row=4, column=0)\n",
    "\n",
    "# Quit button\n",
    "quit_button = tk.Button(root, text=\"Quit\", command=root.destroy, width=10, borderwidth=5, padx=5, pady=5)\n",
    "quit_button.grid(row=4, column=2)\n",
    "\n",
    "root.mainloop()\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Overview over methods defined for project"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Furthermore, an overview should be given over the methods defined in the project. These methods are  written in alphabetic order."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 80,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\u001b[1mcalculate_stat_data\n",
      "\n",
      "\u001b[1mcontroller_smolyak\n",
      "\n",
      "\u001b[1mcost_smolyak\n",
      "\n",
      "\u001b[1mepsilon_cost\n",
      "\n",
      "\u001b[1merror_smolyak\n",
      "\n",
      "\u001b[1mfind_all_sensible_combinations\n",
      "\n",
      "\u001b[1mfind_next_tuples_index\n",
      "\n",
      "\u001b[1mfind_right_position\n",
      "\n",
      "\u001b[1mimplicit_multiplication\n",
      "\n",
      "\u001b[1mload_stat_data\n",
      "\n",
      "\u001b[1mmodified_scatter_plot\n",
      "\n",
      "\u001b[1mmonte_carlo_quad\n",
      "\n",
      "\u001b[1mnewton_cotes\n",
      "\n",
      "\u001b[1mnext_step\n",
      "\n",
      "\u001b[1mone_dim_newton_cotes\n",
      "\n",
      "\u001b[1mone_dim_trapezoidal\n",
      "\n",
      "\u001b[1mqmc_quad\n",
      "\n",
      "\u001b[1mrewrite_function\n",
      "\n",
      "\u001b[1mslice_find\n",
      "\n",
      "\u001b[1msmolyak\n",
      "\n",
      "\u001b[1msort_tuples\n",
      "\n",
      "\u001b[1mstandard_transformations\n",
      "\n",
      "\u001b[1msum_tuple_shape\n",
      "\n",
      "\u001b[0m\n"
     ]
    }
   ],
   "source": [
    "def write_functions(): \n",
    "    functions= [function for function in  dir(Studieproject_one) if \n",
    "                ((not function.startswith('__') and function.find(\"_\") > 0 and function != \"parse_expr\") or function == 'smolyak')]\n",
    "    for k_1 in range(len(functions)):\n",
    "        print('\\033[1m'+functions[k_1])\n",
    "        print(\"\")\n",
    "    print('\\033[0m')\n",
    "write_functions()\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.6"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
